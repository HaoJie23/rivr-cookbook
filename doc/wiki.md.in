# Introduction

## Sample Applications

### Hello World

!set branch hello-world

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 17-28

### Hello World 2

!set branch hello-world-2

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 27-66

# Dialogue basics

## Messages

### Playing a speech synthesis message 

!set branch message-speech-synthesis

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 30-33

### Playing an audio file

!set branch message-audio-file

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 30-33

### Playing an audio file with alternate synthesis text

!set branch message-audio-file-with-alternate

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 30-36

### Playing SSML content

!set branch message-ssml

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 33-48

### Playing mutiple audio items

!set branch message-multiple-items

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 30-35

### Playing a pause

!set branch message-pause

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 31-33

### Specifying message language

!set branch message-language

For each message turn, you can set the `language` field:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 30-34

This can also be done globally at the VoiceXML level:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 36-46

### Queuing a prompt with barge-in for the next interaction

!set branch message-barge-in

First, we need to disable to fetchaudio property.  Maybe the platform default is already empty, but to make sure:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 33-35

Then, we can queue the message with the barge-in flag set.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 37-44

Now, in the next interaction, the VoiceXML prompt queue will be flush because we are entering a _waiting state_.  Since barge-in flag was set,
the user can press a digit during the message and the interaction will complete.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 46-52

## Interactions

### Collecting DTMF

!set branch simple-dtmf-interaction

This example shows how to collect a DTMF string from the caller.  It involves the `Interaction` turn which is created using the `InteractionBuilder`.

The first thing we need to do is to create the `DtmfRecognitionConfiguration`.  This object contains the DTMF grammar used for DTMF recognition.
There are a few [built-in grammars](http://www.w3.org/TR/voicexml20/#dmlABuiltins) specified in the VoiceXML specification.  We are going to use `digits`.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 58-60

Then we need to build the interaction.  We are going to instanciate an `InteractionBuilder` for this task.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 62-62

Then we need to specify the prompts that we are going to use.  This is done with the `addPrompt()` method.  Here we just use a `SpeechSynthesis` message.

To create the `Interaction` itself, we invoke the `build()` method and we pass the `DtmfRecogntionConfiguration` object, meaning that we want to
perform DTMF recognition immediately after prompts are played.  We also need to specify the time-out value, i.e. the time before a `no-input` event is raised.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 63-64

Now that we have an `Interaction`, we can execute it and receive the `InputTurn` which contains the result of this interaction.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 66-66

We now need to inspect the result in order to know what has been done by the user.  We are going to deal with the following two outcomes

1. The user has typed a number
2. The user didn't enter anything

Actually, other outcomes are possible (e.g. hang-up, error) but we'll ignore that for now for the sake of simplicity.
The `InputTurn` contains a `recognitionInfo` property which gives us acces to the recognition result.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 68-76

### Collecting DTMF with interruptible message

!set branch barge-in-dtmf-interaction

This example is very similar to [[Collecting DTMF]].  Here, we will allow the user to type the number while the prompt is being played.  This behaviour is also known as _barge-in_.

In order to do that, we use a diffent signature of the `addPrompt` method.  We use the one where you can specify a `DtmfRecognitionConfiguration`:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 63-65

The `DtmfRecognitionConfiguration` object is used twice in this statement.  It is important to understand why:

1. The fact that we specify a `DtmfRecognitionConfiguration` _in the `addPrompt()` method_ indicates that the user can perform input _while the prompt is playing_.
2. The fact that we specify a `DtmfRecognitionConfiguration` _in the `build()` method_ indicates that the user can also perform input _after the prompts are played_.

### Using a DTMF grammar

!set branch dtmf-grammar

This example shows how to use a DTMF grammar to define what should be accepted during DTMF recognition.

Here a grammar that will accept all North-American valid phone number:

!inline src/main/webapp/grammars/phone-number.grxml

Here's how this should be use in the dialogue:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 58-67

Since the grammar is very simple and it doesn't provide semantic interpration, the result can be obtain
by getting the _utterance_ property of the recognition result.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 69-79

### Using a DTMF grammar with semantic tags

!set branch dtmf-grammar-with-semantic

In the other DTMF recognition examples where a built-in grammar was used, we have rather used the _interpretation_ property of the
recognition result because built-in grammars provide a _semantic interpretation_.  It is better to work with the interpretation than the raw utterance.

In our previous example ([[Using a DTMF grammar]]), the optional "1" will be part of the result if the caller has pressed the key, so we must deal with the fact that
it may be present or not.  In other word, we need to do the normalization in the dialogue.  It's also possible that DTMF _utterance_ will
contains space between each digits (i.e. `5 1 4 5 5 5 1 2 3 4`), so there is another normalization to do there also.

If the grammar provides semantic tags, you have control over what is returned in the recognition result.
Moreover, if you are performing speech recognition and DTMF recognition at once, you can return the same format for the interpretation regardless
of the input mode (i.e. DTMF or speech), making it easier to process in the dialogue.

Here's the phone number grammar modified with semantic tags:

!inline src/main/webapp/grammars/phone-number.grxml 12-45

Here's how to access the result:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 69-79

Note that the phone number doesn't need any normalization at this point.  The optional country code will not be part of the interpretation.

### DTMF recognition options

!set branch dtmf-options

This example shows how to tune DTMF recognition.  The parameters describe here are explained in detail in the VoiceXML specification,
[Section 6.3.3](http://www.w3.org/TR/voicexml20/#dml6.3.3) and [Appendix D - Timing Properties / DTMF Grammar](http://www.w3.org/TR/voicexml20/#L9212)

Let's start by having a grammar accepting a DTMF string between 5 and 10 digits long.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 58-60

Now let's configure the _inter-digit time-out_, i.e. the maximum pause duration between the input of two consecutive digits before the input is considered finished.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 61-61

Another option you can configure is the DTMF _term char_, i.e. the DMTF key the caller can press in order to terminate the input.
This is the DTMF equivalent of the _Enter_ key.  So the user can press the DTMF _term char_ once the input is done,
not having to wait for the _inter-digit time-out_.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 62-62

The last parameter is _term time-out_, i.e. the time given to enter the term char once
when no other character can be accepted (in our exemple, after the 10th digit).  The idea is to put a value
for _term time-out_ that is shorter than _inter-digit time-out_ value.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 63-63

The `DtmfRecognitionConfiguration` can now be used to build the `Interaction`.
Note that the time-out specify here (2 seconds) is the _no-input time-out_ (or simply _timeout_ in the VoiceXML terminology):

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 65-68

You can then perform the DTMF recognition by executing the turn:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 70-82

### Interruptible message

!set branch interruptible-message

Sometime, it is required to play a message while giving the caller a way to interrupt it and skip the rest of it.  The following example explains how to do that.

First, we need to specify a DTMF grammar accepting a single digit:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 55-57

We also reset the DTMF termination character as we want to make the pound key (#) a DTMF input.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 58-58

Then we create the interaction using the `InteractionBuilder` and we only set the `DtmfRecognitionConfiguration` for the prompt.
There is no parameter in the `build()` method since we do not want to perform recognition once the message is played.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 60-66

If we need to check if the prompt has been interrupted, we can check if we got any DTMF recognition (a digit) or a no-match event (pound or asterisk).

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 68-76

### Performing speech-recognition

!set branch simple-speech-interaction

This example shows how to perform speech recognition.  Like DTMF recognition, it involves the `Interaction` which is created with the `InteractionBuilder`.

The first thing we need to do is to create the `SpeechRecognitionConfiguration`.  This object contains the speech grammar used for speech recognition.  There
are a few [built-in grammars](http://www.w3.org/TR/voicexml20/#dmlABuiltins) specified in the VoiceXML specification.  We are going to use `digits`.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 58-60

Then we need to build the interaction.  We are going to instanciate an `InteractionBuilder` for this task.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 62-62

Then we need to specify the prompts that we are going to use.  This is done with the `addPrompt()` method.  Here we just use a `SpeechSynthesis` message.

To create the Interaction itself, we invoke the `build()` method and we pass the `SpeechRecogntionConfiguration` object, meaning that we want to
perform speech recognition immediately after prompts are played.  We also need to specify the time-out value, i.e. the time before a `no-input` event is raise.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 63-64

Now that we have an `Interaction`, we can execute it and receive the `InputTurn` which contains the result of this interaction.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 66-66

We now need to inspect the result in order to know what has been done by the user.  We are going to deal with the following three outcomes:

1. The user said some digits
2. The user said something that could not be understood
3. The user didn't say anything

Actually, other outcomes are possible (e.g. hang-up, error) but we'll ignore that for now for the sake of simplicity.
The `InputTurn` contains a `recognitionInfo` property which gives us acces to the recognition result.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 68-78

### Speech recognition options

!set branch speech-options

This example shows how to tune speech recognition.  The parameters describe here are explained in detail in the VoiceXML specification,
[Section 6.3.2](http://www.w3.org/TR/voicexml20/#dml6.3.2) and part of [Section 6.3.6](http://www.w3.org/TR/voicexml20/#dml6.3.6)

Setting the confidence level, i.e. the minimum confidence level the result must have in order for the recognition not to throw a `nomatch` event:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 62-62

Setting the right confidence level is very difficult.  If you put this value too high, you will create no-matches for utterances that could have
been correct.  On the other hand, setting a value too low will accept incorrect results which should have been discarded.  One way to set this
value correctly is to perform various benchmarks on the recognition engine using the same grammar and a representative sample.

Setting the maximum number of hypotheses (a.k.a. _N-Best_) that should be returned by the recognition engine:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 63-63

Getting several hypotheses allows you to inspect the result and propose the other hypotheses during a confirmation dialogue.  However,
for UI design reasons, you should limit those confirmations to a reasonable number.  Also, asking many hypotheses is more CPU-demanding for
the recognition engine (depends on the grammar used).

Setting the incomplete time-out, i.e. maximum silence duration after end of speech:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 64-64

You may want to set this value high enough to give the user a chance to make pauses while speaking.  However, if you set this value too high, it will take
longer for the engine to end the recognition and return the result.  If you are only asking a yes/no question, this time-out can be short (ie. something around 500 ms).
However, if you are asking a credit card number, this should be longer because people will hesitate and will naturally insert pauses between digit groups, so in this case,
a 1500 ms value would be a good starting point.

Another time-out applying after end of speech, the _complete timeout_, can be set like this:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 65-65

While apparently symmetrical to _incomplete timeout_, the _complete timeout_ is a more advanced setting.  The purpose of this setting is to allow the engine to
end recognition after a pause (the _complete time-out_) if a complete recognition result is _available_.  If used adequatly, this can increase the responsiveness
of the recogntion.

* In this example, if the user says "one two three four" and then pauses, the recognizer does not have a valid recognition result yet
because a minimum of 5 digits is required.  So the _complete time-out_ does not apply here.  At this point, if the pause is longer than _incomplete time-out_,
the recognition will end.
* However, if the user says "one two three four five six" and pauses, the recognizer has a valid recognition result (123456 is allowed
by the grammar) and the recognition result will end after a pause of _complete time-out_.  You can see here that if the complete time-out is too short, hesitation
beyond the 5th digit will cause recognition to end, so you need to consider this while establishing the value.

The _maximum speech timeout_ is the maximum time allowed for speaking.  This value should be greater than the time it reasonnably takes for someone to say a valid answer:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 66-66

If the user speak beyond this duration, the _maxspeechtimeout_ event is triggered.

The _sensitivity_ parameter allows the tuning of the speech detector for barge-in prompts:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 67-67

A value towards 0 will make it harder to barge-in and a value towards 1 will trigger the barge-in for
non-vocal sounds (e.g. clicks, background noise).  Normally, we don't tune this parameter unless the context is unusual.

The _speed versus accuraccy_ parameter controls the balance beetween speed of speech recognition and accuracy of recogntion results:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 68-68

A value towards 0 will make the recognition fast but less accurate.  A value towards 1 will make the speech recogntion longer
(using more CPU) but more accurate.

All the values passed to those methods can also be `null`, meaning that the platform default should be used.

### Recording

!set branch simple-recording

This example shows how to record a message from the caller.

First, a `RecordingConfiguration` object must be created:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 57-57

This object allows us to define the recording behaviour.  The `beep` property will make the beginning of the recording
start with a beep:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 58-58

The `postAudioToServer` (defaults to `true`, explicitly set here for the tutorial purpose) instructs the VoiceXML platform
to send back the audio file of the recording back to the server.  Doing so will allow the dialogue to manipulate the payload of
the recording (typically: write the audio file on the filesystem):

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 59-59

Note: Sending the audio file to the server is not the only thing you can do with a recirding. The `clientSideAssignationDestination` property can be set in
order to store the audio file in a VoiceXML variable (i.e. on the platform, the client-side) and be played later in the dialogue using an `AudioFile`
built from an expression.  See [[Recording with playback]] for more info.

The `type` property sets the audio file format:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 60-60

The `finalSilence` property specifies the silence duration required to stop the recording.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 61-61

If the `dtmfTerm` property is set, the caller can stop the recording by pressing any DTMF key:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 62-62

The `maxTime` property limits the duration of the recording:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 63-63

Once we have our `RecognitionConfiguration` we can build our interaction turn:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 65-69

The turn is then processed as usual:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 71-71

If the recording succeeded, the `recordingInfo` property will be set in the `InputTurn`:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 74-74

The `RecordingInfo` exposes meta-data of the recording:

* `dtmfTerm`: If the recording ended because the user pressed a DTMF key, this property will contain the latter key.
* `duration`: This contains the duration of the recording (in milliseconds).
* `maxTime`: This property is set to `true` is maximum duration is reached.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 75-78

The `RecordingInfo` also contains the recording itself in the `recordingData` property.

* `type`: This property contains the the audio file format (e.g. "audio/x-wav").
* `audioPayload`: This is the audio file itself, exposed as a `byte[]`.
* `filename`: This property contains the filename of the recording, as sent by the VoiceXML platform.

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 80-83

We show in this example how to store the file on disk (on the server-side).

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 85-90
  
Note that you must also check for the `no-input` event as the user might have remained silence and no message
has been recorded:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 91-94

### Recording with playback

!set branch recording-to-variable

It is sometimes useful to play back the recorded message to the user in order to get a confirmation.  To do that,
we just need to temporarly store the audio on the VoiceXML platform.  To do that, we do the same thing as in [[Recording]]
except that we add the following:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 61-61

This will store the recorded audio in a VoiceXML variable in the application 
scope (we will need it later in the dialogue, that's why we need to put it in the `application` scope).

To play back the message, we need to use the `AudioFile` audio item.  Since we are going to play a previously 
recorded file which is stored in a VoiceXML variable, we need to build this `AudioFile` from a JavaScript expression:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 94-96

## Call transfers

### Blind Transfer

!set branch transfer-blind

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 21-29

### Consultation transfer

!set branch transfer-consultation

First, we need to prepare the interaction:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 24-30

Now we have to deal with the result.  First, we check for events:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 32-37

Then, we check the status code:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 38-51

## Subdialogues

### Invoking a subdialogue

!set branch subdialogue-invocation

This example shows how to invoke a VoiceXML subdialogue as defined in the
[VoiceXML specification](http://www.w3.org/TR/voicexml20/#dml2.3.4). 

The output turn required to invoke a subdialogue is a `SubdialogueCall`.  We pass the URL of the 
subdialogue in the constructor:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 25-26

The HTTP request to get the subdialogue will use the POST method:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 28-28

The turn will be executed:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 30-30

The subdialogue return values will be placed in the `value` property of the `InputTurn`.  Let's assume here
that our dialogue returned multiple named values. This will be available in the dialogue as a `JsonObject`:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 32-34

Each property of the JSON object correspond to the return value:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 36-43

The sample comes with a sample VoiceXML subdialogue:

!inline src/main/webapp/subdialogue.vxml

### Invoking a subdialogue and passing HTTP parameters

!set branch subdialogue-invocation-http-parameters

This example shows how to invoke a VoiceXML subdialogue which requires HTTP parameters.

We proceed as with [[Invoking a subdialogue]] but we define a `VariableList` that will contain 
the various parameters.  Be careful as initial value for each parameter is a JavaScript expression, 
so don't forget relevant quoting:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 31-33

We set those parameters in the turn as _submit parameters_:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 34-34

### Invoking a subdialogue and passing VoiceXML parameters

!set branch subdialogue-invocation-voicexml-parameters

This example shows how to invoke a VoiceXML subdialogue which requires VoiceXML parameters (i.e.
uses `<param>` elements).

We proceed as with [[Invoking a subdialogue]] but we define some `SubdialogueParameter` objects.  Those 
objects will be used to create the various `<param>` elements in the generated VoiceXML, so you can either 
create them with a regular _value_ or with a JavaScript _expression_:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 30-32

The `SubdialogueParameter.createWithValue()` expects the parameter name and a string value.  It will yield:

```xml
    <param name="parameter1" value="string" />
```

The `SubdialogueParameter.createWithExpression()` expects the parameter name and a JavaScript expression. The generated VoiceXML will be:

```xml
    <param name="parameter2" expr="2+3" />
    <param name="parameter3" expr="'string'" />
```

We set those parameters in the turn as _subdialogue parameters_:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 33-33

### Implementing a subdialogue

!set branch subdialogue-implementation

To implement a subdialogue is not different from implementing a normal dialogue except that it must end with the
`<return>` VoiceXML element instead of `<exit>`, `<disconnect>`.  To generate a `<return>`, our dialogue simply need to
return a `Return`.  The return can either return named values (JavaScript values) or a VoiceXML event.

Our dialogue ask for two numbers:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 28-31
    
To return those numbers as well as their sum, we prepare a `VariableList`:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 33-36

We need to be careful with variable declarations. Here, since we have numbers, we don't quote the values. The caller
will receive JavaScript numbers, not strings. The resulting VoiceXML will be something like:

```xml
    <var name="number1" expr="12" /> 
    <var name="number2" expr="10" /> 
    <var name="sum" expr="22" /> 
```

We can now pass the `VariableList` in the `Return`:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 38-39

We also show here how to return an event by using the other constructor. Event name is passed in the 
second parameter and message (optional) is passed in the third parameter:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 40-43

Here's a sample VoiceXML document invoking the subdialogue:

!inline src/main/webapp/main.vxml 

To try the example, the VoiceXML platform initial URL should be `http://<yourhostname>:8080/rivr-cookbook/main.vxml`

### Reading subdialogue VoiceXML parameters

!set branch subdialogue-implementation-voicexml-parameter

First, make sure you understand the [[Implementing a subdialogue]] example.  The following example will show you
how to read the parameters sent to a subdialogue using the `<param>` VoiceXML element: 

!inline src/main/webapp/main.vxml 5-7
    
We are going the obtain the subdialogue parameters by declaring variables in the first output turn of the dialogue:   

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 29-31

Note that the variable declaration can contain an initial expression.  In this case, the expression will act as the 
default value of the parameters.  This is shown above with the `promptText2` parameter.

Those declaration must be included in a `Script` turn:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 33-34

This turn is then executed and the subdialogue parameters are available as properties of the `jsonValue`:
  
!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 36-39

# Using vendor-specific VoiceXML platform extensions

## Genesys Voice Platform 8 (GVP 8)

### Obtaining UUID

!set branch genesys-gvp-uuid

GVP Call UUID is exposed under `session.connection.uuid`.  We use a `Script` turn to retrieve it:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 20-37

### Obtaining GVP session ID

!set branch genesys-gvp-session-id

GVP Session ID is exposed under `session.com.genesyslab.sessionid`.  We use a `Script` turn to retrieve it:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 20-37

### Reading user data

!set branch genesys-gvp-read-user-data

This example assumes a SIP Server integration (not the CTI connector).

This example shows how to extract user data sent by the SIP Server at the beggining of the call.  The SIP server sends the user
data in specific headers of the SIP INVITE message, typically the ones prefixed with `X-Genesys-`:

    X-Genesys-CustomerName: Peter Johnson
    X-Genesys-AccountNumber: 55534-53124-67110

GVP will map these headers to the `session.com.genesyslab.userdata` object, making it available to the VoiceXML application. We only
need to use a `Script` to retrieve it:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 22-49

Note that if user data are updated during the GVP call, the updated data cannot be read from the VoiceXML because it's only passed from
SIP Server to GVP in the SIP INVITE _at the beggining of the call_.

# Integration

## JUnit

### Simple dialogue tests

Unit testing is one of Rivr most notable feature. It allows the developer to perform non-regression testing with automated tools.  Using this technique, you can
simulate hundreds of call in seconds.

!set branch junit-dialogue-test

Suppose we have a simple dialogue and we want to write unit tests for it:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 27-79

We first need to write a unit test class in which we will initialize a `VoiceXmlTestDialogueChannel` which is an implementation
of `DialogueChannel` used for testing.  This implementation allows us to simulate responses from the VoiceXML platform such as recognition results and no-match events.

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 30-33

This dialogue channel must be set in the dialogue context we will use in our test cases:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 35-40

The rest of the class is a mix of test methods (annotated with `@org.junit.Test` annotation) and helper methods.

Let's take a look at our first test case:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 42-58

The first thing to do is (obviously!) to start the dialogue.

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 44-44

We have used the `startDialogue()` helper method to do so:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 138-140

We then need to perform some kind of check to validate that the dialogue is executing correctly.  We know that the first thing the
dialogue should do is to play the welcome message, so let's verify that:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 45-45

Since other test cases also require to perform this check, we have extracted the logic in
the `assertWelcomeMessage()` helper method:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 142-144

The `assertMessage()` method ensure that the dialogue is generating a `Message` turn and that the audio items are as expected:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 159-164

Note that in this method, we use the `getLastStepAsOutputTurn()` method on our test dialogue channel to query the last _step_ that
occured in the channel.  The step can be one of:

* Output turn
* Last turn
* Error

Depending on the expected type of step at this point in the dialogue, we can invoke respectively

* `mChannel.getLastStepAsOutputTurn()`
* `mChannel.getLastStepAsLastTurn()`
* `mChannel.getLastStepAsError()`

So the `assertMessage()` method will ensure

1. that we have, at this point in the dialogue, an `OutputTurn` for which the type is `Message`
2. that the audio items of this message turn are as expected

Note that we are only asserting some aspects of the `Message`.  We didn't test neither the `language` nor `barge-in` properties.
Thus it's possible to make the test cases as sophisticated as needed.  There's always a trade-off between what is actually asserted in
unit tests and the effort required to develop those test cases.  You have control over what you depth of assertion for each turn.

Geting back at our example, now we'll simulate the VoiceXML platform response.  In this case, since we have a message, the only possible response
from the platform (beside an `error` event) is what we call a _no-action_, i.e. an input turn without any property set.  In order to simulate this platform response, we invoke the
`processNoAction()` method on the dialogue channel:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 47-47

The dialogue will then progress to the next turn.

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 48-48

The `assertPromptForNumber()` validates that we have an interaction turn, parameterized for DTMF recogition and having some specific messages:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 146-150

This method uses two additionnal helper methods `assertDtmfInteraction` and `assertInteraction`:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 166-182

Again, we see that we can build many reusable helper methods that will make each test case very terse.

To simulate DTMF processing, including semantic result, we do:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 50-50

The first argument is the raw input (DTMF recognizer will sometimes separate digits with spaces), the second one is the semantic result, the third one is a mark
info (not covered here). Next step is to validate the feedback message:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 51-51

At this point, you may have noticed that we have always follow this pattern:

* perform some action
* assert something

Using a white line between each block will help you remain organized in you test case method code.

To assert the result of the dialogue, we only need to assert the `LastTurn`:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 54-57

With `assertExit()` defined as:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 184-190

If we only run JUnit for the test case `testNormal()` we do not completely every outcome of the callflow.  This can be verified by running JUnit in conjunction
with a coverage tool.  I will be using [Emma](http://emma.sourceforge.net/) with the [Eclipse plug-in](http://www.eclemma.org/):

![Emma code coverage in Eclipse](http://nuecho.github.io/rivr/cookbook-resources/0.9.3/eclipse-coverage-1.png "Emma code coverage in Eclipse")

Adding 3 other test cases, we can achieve complete coverage:

!inline src/test/java/com/nuecho/rivr/cookbook/test/DialogueTest.java 60-136

![Emma code coverage in Eclipse](http://nuecho.github.io/rivr/cookbook-resources/0.9.3/eclipse-coverage-2.png "Emma code coverage in Eclipse")

## Server-side integration

### Spring framework integration

!set branch spring

There are so many ways you can leverage the [Spring framework](http://projects.spring.io/spring-framework/).
This example will show you how to provide a custom dialogue factory that will create `VoiceXmlDialogue` objects
from the Spring bean factory.

The first step is to create a Dialogue as a Java bean:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 17-41

Note that this dialogue has a mandatory _message_ property.

Now in the bean factory configuration file, we can provide some definitions for some _dialogue beans_:

!inline src/main/webapp/WEB-INF/applicationContext.xml

We make those beans as _prototype_, meaning that they are reinstanciated each time they are requested.  This is required
if the dialogue class is stateful (which is not really the case in our example).  A stateless dialogue bean can be
shared across many "phone calls" while a stateful dialogue bean can only used by one call.

You need to set the application context in the web.xml:

!inline src/main/webapp/WEB-INF/web.xml 11-13

We can define a custom dialogue factory that will lookup the dialogue in the bean factory according to
the value of the `dialogue` HTTP parameter:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/DialogueFactory.java 21-56

You need to place the name of the dialogue factory class in the `web.xml`:

!inline src/main/webapp/WEB-INF/web.xml 19-22

You can try it with the following URI:

- [http://localhost:8080/rivr-cookbook/dialogue?dialogue=x](http://localhost:8080/rivr-cookbook/dialogue?dialogue=x)
- [http://localhost:8080/rivr-cookbook/dialogue?dialogue=y](http://localhost:8080/rivr-cookbook/dialogue?dialogue=y)

# Other recipes

## Getting information from the platform

### Getting CLID and DNIS

!set branch clid-dnis

This example shows how to get the CLID (also known as ANI) and DNIS from the VoiceXML platform.  To do that, we need to read two read-only
[variables specified by the VoiceXML specification](http://www.w3.org/TR/voicexml20/#dml5.1.4):

> `session.connection.local.uri`

>> This variable is a URI which addresses the local interpreter context device.

> `session.connection.remote.uri`

>> This variable is a URI which addresses the remote caller device.

To create a VoiceXML document reading platform variables, we use the `Script` turn.  This turn will generate a VoiceXML document that will perform the following step:

1. Initialize some variables with some optional expression.
2. Execute an optional script
3. Send back the variables to the server

Here, we will only need to initialize two variables and send the result back to our dialogue, no need for a script here as initial value assignment is enough.
To define the variables and initial expression, we use the `VariableList` class:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 24-26

Then we create the `Script` turn with theses variable definitions:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 28-29

We execute the turn:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 31-31

To retrieve the result, we cast the `inputTurn.getValue()` into a `JsonObject`.  The affected values for the variables can be obtained as property of this object:

!inline src/main/java/com/nuecho/rivr/cookbook/dialogue/Dialogue.java 33-36

Note that the CLID and DNIS obtained this way are URI.  If you have a SIP IVR platform integrated with the PSTN, you are likely to get SIP URI (e.g. `sip:+15145551234@proxy.example.com`) so you probably need to do
some parsing in order to extract the numeric value of the SIP URI.
